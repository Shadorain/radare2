%{
// gperf -aclEDCIG --null-strings -H sdb_hash_c_riscv -N sdb_get_c_riscv -t riscv.gperf > riscv.c
// gcc -DMAIN=1 riscv.c ; ./a.out > riscv.h
#include <stdio.h>
#include <ctype.h>
%}

struct kv { const char *name; const char *value; };
%%
bne,"branch if not equal"
c.addi4spn,"add unsigned immediate*4 to stack pointer (compressed instruction)"
divuw,"unsigned division of words (32 bits)"
or,"bitwise OR"
c.ldsp,"load double word (64 bits), SP relative (compressed instruction)"
fmv.x.s,"move integer register to double"
fsqrt.s,"floating-point square root, single precision"
lb,"load byte"
subw,"subtract word (32 bits)"
bge,"branch if greater than"
ld,"load double word (64 bits)"
andi,"bitwise and with immediate"
fcvt.d.wu,"convert to double from unsigned word (32 bits)"
amomaxu.w,"atomic memory operation, unsigned integer maximum (32 bits)"
c.lui,"load upper immediate (compressed instruction)"
fcvt.l.d,"convert to long (64 bits) from double"
c.fsd,"floating-point store, double precision (compressed instruction)"
auipc,"add upper immediate to PC"
amoor.d,"atomic memory operation, bitwise OR (64 bits)"
c.andi,"bitwirse AND with immediate (compressed instruction)"
and,"bitwise and"
amominu.w,"atomic memory operation, unsigned integer minimum (32 bits)"
mrts,"machine redirect trap to supervisor"
lr.w,"load reserved (32 bits)"
c.jr,"jump, register relative (compressed instruction)"
eret,"environment return"
fmax.s,"floating-point maximum, single precision"
fnmsub.d,"floating-point negated multiply-subtract, double precision"
c.sdsp,"store double word (64 bits), SP relative (compressed instruction)"
c.fld,"floating-point load, double precision (compressed instruction)"
c.srai,"shift right arithmetically by immediate (compressed instruction)"
divw,"signed division of words (32 bits)"
lr,"load reserved"
bgt,"branch if greater than"
divu,"unsigned division"
flt.s,"floating-point 'less than', double precision"
lw,"load word (32 bits)"
lr.d,"load reserved (64 bits)"
ori,"bitwise OR with immediate"
c.addw,"add 32-bit words (compressed instruction)"
fcvt.l.s,"convert to long (64 bits) from single"
srlw,"shift right logically (32 bits)"
fnmsub.s,"floating-point negated multiply-subtract, single precision"
c.sw,"store word (32 bits) (compressed instruction)"
amominu.d,"atomic memory operation, unsigned integer minimum (64 bits)"
remw,"remainder of division (32 bits)"
neg,"two's complement"
remu,"remainder of unsigned division"
fsgnjn.s,"floating-point negated sign-injection, single precision"
c.flw,"floating-point load, single precision (compressed instruction)"
flt.d,"floating-point 'less than', double precision"
csrrwi,"atomic read/write CSR with immediate"
csrrw,"atomic read/write CSR"
fmax.d,"floating-point maximum, double precision"
j,"jump"
csrrs,"atomic read and set bit in CSR"
xori,"exclusive or with immediate"
add,"add"
c.sd,"store double word (64 bits) (compressed instruction)"
addi,"add immediate"
fcvt.s.lu,"convert to single from unsigned long (64 bits)"
csrrc,"atomic read and clear bit in CSR"
addw,"add 32-bit words"
lwu,"load word (32 bits) unsigned"
mv,"copy"
fsgnjn.d,"floating-point negated sign-injection, double precision"
fnmadd.d,"floating-point negated multiply-add, double precision"
c.fsdsp,"floating-point store, double precision, SP relative (compressed instruction)"
c.addi16sp,"add signed immediate*16 to stack pointer (compressed instruction)"
slliw,"shift left logically by immediate (32 bits)"
rdinstreth,"read 'instructions retired' counter, high half"
not,"one's complement"
amoswap.w,"atomic memory operation, swap (32 bits)"
c.ebreak,"environment breakpoint (compressed instruction)"
rdcycleh,"read cycle counter, high half"
c.addiw,"add immediate to 32-bit word (compressed instruction)"
nop,"no operation"
fnmadd.s,"floating-point negated multiply-add, single precision"
fmin.d,"floating-point minimum, double precision"
fcvt.d.l,"convert to double from long (64 bits)"
rdtime,"read real-time clock"
c.swsp,"store word (32 bits), SP relative (compressed instruction)"
amomin.d,"atomic memory operation, signed integer minimum (64 bits)"
rdcycle,"read cycle counter"
fcvt.d.w,"convert to double from word (32 bits)"
amoswap.d,"atomic memory operation, swap (64 bits)"
fdiv.s,"floating-point division, single precision"
fcvt.wu.d,"convert to unsigned word (32 bits) from double"
fcvt.d.s,"convert to double from single"
fadd.d,"floating-point add, double precision"
sc.w,"store conditional (32 bits)"
srai,"shift right arithmetically by immediate"
fsgnj.s,"floating-point sign-injection, single precision"
amomin.w,"atomic memory operation, signed integer minimum (32 bits)"
fmv.d.x,"move double to integer register"
fmin.s,"floating-point minimum, single precision"
sraw,"shift right arithmetically (32 bits)"
fence.i,"instruction cache fence"
fdiv.d,"floating-point division, double precision"
jalr,"jump and link (call); register-based"
sra,"shift right arithmetically"
fcvt.wu.s,"convert to unsigned word (32 bits) from single"
fcvt.w.s,"convert to word (32 bits) from single"
c.xor,"exclusive OR (compressed instruction)"
fsgnj.d,"floating-point sign-injection, double precision"
srl,"shift right logically"
feq.s,"floating-point 'equals', single precision"
jr,"jump register"
negw,"two's complement word"
mulw,"multiply word (32 bits)"
sc.d,"store conditional (64 bits)"
addiw,"add immediate to 32-bit word"
c.srli,"shift right logically by immediate (compressed instruction)"
fcvt.w.d,"convert to word (32 bits) from double"
fadd.s,"floating-point add, single precision"
ecall,"environment call"
c.beqz,"branch if equal to zero (compressed instruction)"
c.or,"bitwise OR (compressed instruction)"
lbu,"load byte, unsigned"
fsw,"floating-point store word (single precision value)"
feq.d,"floating-point 'equals', double precision"
fle.d,"floating-point 'less or equal', double precision"
sfence.vm,"supervisor-mode fence for virtual memory"
mulh,"multiply, high half"
amoadd.d,"atomic memory operation, add (64 bits)"
fmsub.d,"floating-point multiply-subtract, double precision"
sw,"store word (32 bits)"
c.subw,"subtract words (32 bits) (compressed instruction)"
sub,"subtract"
c.fldsp,"floating-point load, double precision, SP relative (compressed instruction)"
c.fswsp,"floating-point store, single precision, SP relative (compressed instruction)"
fclass.d,"classify floating point number, double precision"
mul,"multiply"
lui,"load upper immediate"
bgeu,"branch if greater than, unsigned"
div,"signed division"
fcvt.s.w,"convert to single from word (32 bits)"
fsd,"floating-point store double"
fmv.s.x,"move single to integer register"
ebreak,"environment breakpoint"
fclass.s,"classify floating point number, single precision"
c.sub,"subtract (compressed instruction)"
amoadd.w,"atomic memory operation, add (32 bits)"
sd,"store double word (64 bits)"
seqz,"set if equal to zero"
c.and,"bitwise AND (compressed instruction)"
sb,"store byte"
amoxor.d,"atomic memory operation, "
sc,"store conditional"
fle.s,"floating-point 'less or equal', single precision"
bgez,"branch if greater than or equal to zero"
fmsub.s,"floating-point multiply-subtract, single precision"
rdinstret,"read 'instructions retired' counter"
fcvt.s.d,"convert to single from double"
fmadd.d,"floating-point multiply-add, double precision"
sh,"store half-word (16 bits)"
fcvt.s.l,"convert to single from long (64 bits)"
fld,"floating-point load double"
lhu,"load half-word (16 bits), unsigned"
sgtz,"set if greater than zero"
c.mv,"move (compressed instruction)"
amoxor.w,"atomic memory operation, "
fmadd.s,"floating-point multiply-add, single precision"
csrrsi,"atomic read and set immediate bit in CSR"
bltz,"branch if less than zero"
slti,"set if less than immediate"
flw,"floating-point load word"
bltu,"branch if less than, unsigned"
c.ld,"load double word (64 bits) (compressed instruction)"
fsgnjx.d,"floating-point XOR sign-injection, double precision"
sltiu,"set if less than immediate, unsigned"
sllw,"shift left logically (32 bits)"
blez,"branch if less than or equal to zero"
sltz,"set if less than zero"
rdtimeh,"read real-time clock, high half"
fcvt.lu.s,"convert to unsigned long (64 bits) from single"
fmul.s,"floating-point multiply, single precision"
bgtu,"branch if greater than, unsigned"
jal,"jump and link (call)"
bleu,"branch if less than or equal to, unsigned"
c.lwsp,"load word (32 bits), SP relative (compressed instruction)"
rem,"remainder of division"
c.li,"load immediate (compressed instruction)"
c.bnez,"branch if not equal to zero (compressed instruction)"
sltu,"set if less than, unsigned"
amomax.w,"atomic memory operation, signed integer maximum (32 bits)"
c.lw,"load word (32 bits) (compressed instruction)"
ble,"branch if less than or equal to"
fence,"memory fence"
amoand.d,"atomic memory operation, bitwise AND (64 bits)"
bgtz,"branch if greater than zero"
c.flwsp,"floating-point load, single precision, SP relative (compressed instruction)"
fsgnjx.s,"floating-point XOR sign-injection, single precision"
mulhsu,"multiply signed*unsigned, high half"
fmul.d,"floating-point multiply, double precision"
mulhu,"multiply unsigned, high half"
amomax.d,"atomic memory operation, signed integer maximum (64 bits)"
sraiw,"shift right arithmetically by immediate (32 bits)"
fcvt.lu.d,"convert to unsigned long (64 bits) from double"
remuw,"remainder of unsigned division (32 bits)"
hrts,"hypervisor redirect trap to supervisor"
amoand.w,"atomic memory operation, bitwise AND (32 bits)"
slli,"shift left logically by immediate"
fsub.d,"floating-point subtract, double precision"
blt,"branch if less than"
beq,"branch if equal"
c.jalr,"jump and link, register relative (compressed instruction)"
csrrci,"atomic read and clear immediate bit in CSR"
beqz,"branch if equal to zero"
fcvt.s.wu,"convert to single from unsigned word (32 bits)"
fsub.s,"floating-point subtract, single precision"
snez,"set if not equal to zero"
slt,"set if less than"
fcvt.d.lu,"convert to double from unsigned long (64 bits)"
c.j,"jump (compressed instruction)"
mrth,"machine redirect trap to hypervisor"
xor,"exclusive or"
fmv.x.d,"move integer register to double"
c.add,"add (compressed instruction)"
c.slli,"logical left shift by immediate (compressed instruction)"
c.jal,"jump and link (compressed instruction)"
amomaxu.d,"atomic memory operation, unsigned integer maximum (64 bits)"
sll,"shift left logically"
fsqrt.d,"floating-point square root, double precision"
li,"load immediate"
lh,"load half-word (16 bits)"
amoor.w,"atomic memory operation, bitwise OR (32 bits)"
bnez,"branch if not equal to zero"
c.fsw,"floating-point store, single precision (compressed instruction)"
wfi,"wait for interrupt"
srliw,"shift right logically by immediate (32 bits)"
c.addi,"add immediate  (compressed instruction)"
srli,"shift right logically by immediate"
%%
// SDB-CGEN V1.7.0
// 0x55c6143ac170
const char* gperf_riscv_get(const char *s) {
	const struct kv *o = sdb_get_c_riscv (s, strlen(s));
	return o? o->value: NULL;
}
const unsigned int gperf_riscv_hash(const char *s) {
	return sdb_hash_c_riscv(s, strlen (s));
}
struct {const char*name;void*get;void*hash;} gperf_riscv = {
	.name = "riscv",
	.get = &gperf_riscv_get,
	.hash = &gperf_riscv_hash
};

#if MAIN
int main () {
	char line[1024];
	FILE *fd = fopen ("riscv.gperf", "r");
	if (!fd) {
		fprintf (stderr, "Cannot open riscv.gperf\n");
		return 1;
	}
	int mode = 0;
	printf ("#ifndef INCLUDE_riscv_H\n");
	printf ("#define INCLUDE_riscv_H 1\n");
	while (!feof (fd)) {
		*line = 0;
		fgets (line, sizeof (line), fd);
		if (mode == 1) {
			char *comma = strchr (line, ',');
			if (comma) {
				*comma = 0;
				char *up = strdup (line);
				char *p = up; while (*p) { *p = toupper (*p); p++; }
				printf ("#define GPERF_riscv_%s %d\n",
					line, sdb_hash_c_riscv (line, comma - line));
			}
		}
		if (*line == '%' && line[1] == '%')
			mode++;
	}
	printf ("#endif\n");
}
#endif

