%{
// gperf -aclEDCIG --null-strings -H sdb_hash_c_lm32 -N sdb_get_c_lm32 -t lm32.gperf > lm32.c
// gcc -DMAIN=1 lm32.c ; ./a.out > lm32.h
#include <stdio.h>
#include <ctype.h>
%}

struct kv { const char *name; const char *value; };
%%
cmpnei,"compare not equal immediate"
xnori,"xnor immediate"
shgotoff,"store half word got offset"
calli,"call immediate"
srui,"shift right unsigned immediate"
mul,"mulitply"
cmpne,"compare not equal"
divu,"unsigned divide"
sbgotoff,"store byte got offset"
xor,"xor"
swgotoff,"store word got offset"
call,"call"
bge,"branch greater or equal"
mvui,"move unsigned immediate"
ori,"or immediate"
lhgotoff,"load half word got offset"
mv,"move"
bg,"branch greater"
be,"branch equal"
cmpei,"compare equal immediate"
user,"user defined instruction"
and,"and"
wcsr,"write control or status register"
orhii,"or high immediate"
nori,"nor immediate"
bgu,"branch greater unsigned"
bne,"branch not equal"
sw,"store word"
cmpgu,"compare greater than unsigned"
lbu,"load byte unsigned"
mvhi,"move high immediate"
sr,"shift right"
andhii,"and high immediate"
addgotoff,"add got offset"
bi,"branch immediate"
bret,"return from breakpoint"
break,"breakpoint"
lhugotoff,"load half word got offset unsigned"
add,"add"
sli,"shift left immediate"
xori,"xor immediate"
cmpgi,"compare greater than immediate"
lhu,"load halfword unsigned"
lbugprel,"load byte unsigned gp relative"
bgeu,"branch greater or equal unsigned"
addi,"add immediate"
cmpge,"compare greater or equal"
sb,"store byte"
scall,"system call"
lwgprel,"load word gp relative"
lhgprel,"load halfword gp relative"
lhugprel,"load halfword unsigned gp relative"
sl,"shift left"
xnor,"xnor"
lbgprel,"load byte gp relative"
sh,"store halfword"
lbgotoff,"load byte got offset"
swgprel,"store word gp relative"
cmpg,"compare greater than"
sri,"shift right immediate"
rcsr,"read control or status register"
andi,"and immediate"
cmpe,"compare equal"
cmpgeui,"compare greater or equal unsigned immediate"
cmpgeu,"compare greater or equal unsigned"
sru,"shift right unsigned"
orhigotoffi,"or high got offset immediate"
lh,"load halfword"
sbgprel,"store byte gp relative"
ret,"return"
lwgotrel,"load word got relative"
muli,"multiply immediate"
cmpgei,"compare greater or equal immediate"
lbugotoff,"load byte got offset unsigned"
sexth,"sign extend half-word"
lb,"load byte"
cmpgui,"compare greater than unsigned immediate"
sextb,"sign extend byte"
sub,"subtract"
modu,"unsigned modulus"
mvi,"move immediate"
shgprel,"store halfword gp relative"
b,"branch"
eret,"return from exception"
mva,"move address"
lw,"load word"
not,"not"
or,"or"
nop,"nop"
nor,"nor"
lwgotoff,"load word got offset"
%%
// SDB-CGEN V1.7.0
// 0x564bb8766160
const char* gperf_lm32_get(const char *s) {
	const struct kv *o = sdb_get_c_lm32 (s, strlen(s));
	return o? o->value: NULL;
}
const unsigned int gperf_lm32_hash(const char *s) {
	return sdb_hash_c_lm32(s, strlen (s));
}
struct {const char*name;void*get;void*hash;} gperf_lm32 = {
	.name = "lm32",
	.get = &gperf_lm32_get,
	.hash = &gperf_lm32_hash
};

#if MAIN
int main () {
	char line[1024];
	FILE *fd = fopen ("lm32.gperf", "r");
	if (!fd) {
		fprintf (stderr, "Cannot open lm32.gperf\n");
		return 1;
	}
	int mode = 0;
	printf ("#ifndef INCLUDE_lm32_H\n");
	printf ("#define INCLUDE_lm32_H 1\n");
	while (!feof (fd)) {
		*line = 0;
		fgets (line, sizeof (line), fd);
		if (mode == 1) {
			char *comma = strchr (line, ',');
			if (comma) {
				*comma = 0;
				char *up = strdup (line);
				char *p = up; while (*p) { *p = toupper (*p); p++; }
				printf ("#define GPERF_lm32_%s %d\n",
					line, sdb_hash_c_lm32 (line, comma - line));
			}
		}
		if (*line == '%' && line[1] == '%')
			mode++;
	}
	printf ("#endif\n");
}
#endif

