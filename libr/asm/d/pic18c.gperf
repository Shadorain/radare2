%{
// gperf -aclEDCIG --null-strings -H sdb_hash_c_pic18c -N sdb_get_c_pic18c -t pic18c.gperf > pic18c.c
// gcc -DMAIN=1 pic18c.c ; ./a.out > pic18c.h
#include <stdio.h>
#include <ctype.h>
%}

struct kv { const char *name; const char *value; };
%%
addwf,"add wreg and f"
decfsz,"decrement f, skip if 0"
decf,"decrement f"
subwfb,"subtract wreg from f with borrow"
movlb,"move literal to bsr<3:0>"
xorlw,"exclusive or literal with wreg"
subfwb,"subtract f from wreg with borrow"
cpfsgt,"compare f with wreg, skip >"
subwfi,"subtract wreg from f"
swapf,"swap nibbles in f"
tstfsz,"test f, skip if 0"
sublw,"subtract wreg from literal"
call,"call subroutine"
push,"push top of return stack (tos)"
tblrd*,"table read with pre-increment"
btfss,"bit test f, skip if set"
iorwf,"inclusive or wreg with f"
retfie,"return from interrupt enable"
incfsz,"increment f, skip if not 0"
daw,"decimal adjust wreg"
bra,"branch unconditionally"
tblwt*-,"table write with post-decrement"
clrwdt,"clear watchdog timer"
tblwt*+,"table write with post-increment"
iorlw,"inclusive or literal with wreg"
movff,"move fs (source) to fd (destination)"
pop,"pop top of return stack (tos)"
nop,"no operation"
cpfseq,"compare f with wreg, skip ="
rrncf,"rotate right f (no carry)"
bov,"branch if overflow"
conf,"complement f"
addlw,"add literal and wreg"
bnov,"branch if not overflow"
sleep,"go into standby mode"
bsf,"bit set f"
addwfc,"add wreg and carry bit to f"
bc,"branch if carry"
tblwt*,"table write"
xorwf,"exclusive or wreg with f"
rrcf,"rotate right f through carry"
bcf,"bit clear f"
bn,"branch if negative"
dcfsnz,"decrement f, skip if not 0"
tblrd*+,"table read with post-increment"
negf,"negate f"
andlw,"and literal with wreg"
movwf,"move wreg to f"
mulwf,"multiply wreg with f"
tblrd*-,"table read with post-decrement"
bnn,"branch if not negative"
andwf,"and wreg with f"
goto,"go to address"
return,"return from subroutine"
reset,"software device reset"
bnc,"branch if not carry"
movlw,"move literal to wreg"
mullw,"multiply literal with wreg"
setf,"set f"
movf,"move f"
retlw,"return with literal in wreg"
rcall,"relative call"
incf,"increment f, skip if 0"
lfsr,"move literal (12-bit) to fsrx"
cpfslt,"compare f with wreg, skip <"
bz,"branch if zero"
tblwt+*,"table write with pre-increment"
bnz,"branch if not zero"
rlcf,"rotate left f through carry"
btg,"bit toggle f"
clrf,"clear f"
rlncf,"rotate left f (no carry)"
btfsc,"bit test f, skip if clear"
%%
// SDB-CGEN V1.7.0
// 0x55904e394170
const char* gperf_pic18c_get(const char *s) {
	const struct kv *o = sdb_get_c_pic18c (s, strlen(s));
	return o? o->value: NULL;
}
const unsigned int gperf_pic18c_hash(const char *s) {
	return sdb_hash_c_pic18c(s, strlen (s));
}
struct {const char*name;void*get;void*hash;} gperf_pic18c = {
	.name = "pic18c",
	.get = &gperf_pic18c_get,
	.hash = &gperf_pic18c_hash
};

#if MAIN
int main () {
	char line[1024];
	FILE *fd = fopen ("pic18c.gperf", "r");
	if (!fd) {
		fprintf (stderr, "Cannot open pic18c.gperf\n");
		return 1;
	}
	int mode = 0;
	printf ("#ifndef INCLUDE_pic18c_H\n");
	printf ("#define INCLUDE_pic18c_H 1\n");
	while (!feof (fd)) {
		*line = 0;
		fgets (line, sizeof (line), fd);
		if (mode == 1) {
			char *comma = strchr (line, ',');
			if (comma) {
				*comma = 0;
				char *up = strdup (line);
				char *p = up; while (*p) { *p = toupper (*p); p++; }
				printf ("#define GPERF_pic18c_%s %d\n",
					line, sdb_hash_c_pic18c (line, comma - line));
			}
		}
		if (*line == '%' && line[1] == '%')
			mode++;
	}
	printf ("#endif\n");
}
#endif

